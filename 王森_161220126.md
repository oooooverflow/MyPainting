# 《计算机图形学》系统技术报告
> 南京大学计算机系 王森 161220126
## 概述
### 开发环境
| 操作系统 | 框架基础 | 编程语言 |
|:-:|:-:|:-:|
| Windows10 | Qt 5.11.0 | C++ |
### 功能说明
* 直线、圆、椭圆、多边形、曲线的绘制。
* 直线、圆、椭圆、多边形、曲线的绘制编辑。
* 直线、圆、椭圆。多边形、曲线的平移、旋转、缩放。
* 区域填充。
* 裁剪。
* 读取现有图片。
* 将绘制的图像保存为图片。
* 选择画笔的颜色。
* 读取OFF格式的文件并显示三维图元，可通过按键控制三维图元的旋转，缩放。
## 算法介绍
### 直线绘制算法: DDA算法
*  核心：利用光栅特性(屏幕单位网格表示像素列阵)，使用x或y方向单位增量(△x或△y=±1)来离散取样，并逐步计算沿线路径各像素位置。首先计算直线的斜率，确定斜率和1的关系从而确定主变化的坐标轴（x或y），在主坐标轴上以单位间隔对线段离散取样，确定另一个坐标轴上最靠近线段路径的对应整数值。
*  斜率的绝对值小于1时，在X方向取样，计算Y方向位置坐标，反之相反。
*  其中需要注意的是，会对计算出的坐标点取整（因为像素点的坐标都是整数）确定距离直线最近的像素点。
![](https://i.imgur.com/hdVnjs9.png "DDA直线绘制算法")
### 圆绘制算法： Bresenham 画圆算法的改进算法
* 核心：根据圆的对称性，只需画出右上角的八分之一个圆弧即可画出其余的圆弧。通过前一个已确定的像素点，选出候选的两个像素点，再根据决策参数，在候选像素中选择接近圆周的像素。在0≤x≤y的1/8圆周上，象素坐标x值单调增加，y值单调减少。设第i步已确定（xi,yi）是要画圆上的象素点，看第i+1步象素点（xi+1,yi+1）应如何确定。下一个象素点只能是(xi+1,yi)或(xi+1,yi-1)中的一个。
* 设这两个点分别为a和b，则可计算出圆弧距离这两个点的距离的平方，Da = (xi+1)2+yi2-R2,Db = R2-(xi+1)2-(yi-1)2。设Pi = Da-Db为判断量，根据精确圆弧虽在位置与对应Pi的正负关系可得出以下结论：当Pi<0时，选a点为下一个象素点，当Pi<0 ≥0时，选b点为下一个象素点。而根据前一个计算出的Pi值可以继续去计算出下两个候选点的Pi+1的值，当Pi≥0时，应选b点，则Pi+1 = Pi+4(Xi-Yi)+10，当Pi<0时，应选a，则Pi+1 = Pi+4Xi+6。这样就可以增量的形式由上一个判断量计算出下一个判断量。
* 起始点的P值是可以直接计算出来的。
![](https://i.imgur.com/BPrbHy1.png "Bresenham画圆算法")
### 椭圆绘制算法: 中点算法
* 核心：定义椭圆弧上某点的切线法向量N如下：  
![](https://i.imgur.com/5GbYdv8.png "切线法向量")
* dy/dx = -1的点是椭圆弧上的分界点。此点之上的部分（橙褐色部分）椭圆弧法向量的y分量比较大，即：2b2(x+1) < 2a2(y-0.5)；此点之下的部分（蓝紫色部分）椭圆弧法向量的x分量比较大，即：2b2(x+1) > 2a2(y-0.5)。
* 对于图中橙褐色标识的上部区域，y方向每变化1个单位，x方向变化大于一个单位，因此中点算法需要沿着x方向步进画点，x每次增量加1，求y的值。同理，对于图中蓝紫色标识的下部区域，中点算法沿着y方向反向步进，y每次减1，求x的值。
* 假设当前位置是P(xi, yi)，则下一个可能的点就是P点右边的P1(xi+1, yi)点或右下方的P2(xi+1, yi-1)点，取舍的方法取决于判别式di，di的定义如下：di = F(xi+1, yi-0.5) = b2(xi+1)2 + a2(yi-0.5)2 – a2b2
* 若di < 0，表示像素点P1和P2的中点在椭圆内，这时可取P1为下一个像素点。此时xi+1 = xi+1，yi+1 = yi，代入判别式di得到di+1：
di+1 = F(xi+1+1, yi+1-0.5) = b2(xi+2)2 + a2(yi-0.5)2 – a2b2 = di + b2(2xi + 3).计算出di的增量是b2(2xi + 3)。
* 同理，若di >= 0，表示像素点P1和P2的中点在椭圆外，这时应	当取P2为下一个像素点。此时xi+1 = xi+1，yi+1 = yi-1，代入判别式di得到di+1：di+1 = F(xi+1+1, yi+1-0.5) = b2(xi+2)2 + a2(yi-1.5)2 – a2b2 = d1 + b2(2xi+3) + a2(-2yi+2)
计算出di的增量是b2(2xi+3)+a2(-2yi+2)。
*  需要注意的是，椭圆类中引入角度作为成员变量，计算出每个标准化椭圆上的点后，将该点旋转后的点计算出来，再将点打在画布上。初始化时，椭圆的角度为0。
### 多边形绘制算法
* 核心: 多边形由多条直线构成，则会之多边行可转换为绘制多条直线。鼠标点击第一个点后，没电下一个点都会和前一个点相连，直到点击的点与第一个点十分接近才形成闭合图形。因此在捕捉鼠标点击位置坐标后，用容器存储该点，并复用直线绘制函数即可绘制当前边。
* 值得注意的是，多边形引入了角度的概念，在每次绘制之前，都会讲控制点绕中心点旋转角度后，再在旋转后的控制点上绘制。  
![](https://i.imgur.com/RJSuXbu.png "多边形绘制算法")
### 曲线绘制算法: Cardinal样条
* 核心:Cardinal样条由四个连续控制点给出,中间两个控制点是曲线段端点，另二个点用来计算终点斜率。  
![](https://i.imgur.com/1PXBeKb.png "Cardinal样条")
* 在控制点Pk和Pk+1间Cardinal样条段的参数向量函数P(u)，其端点处的切向量正比于由相邻控制点所形成的弦。
* 设P(u)是两控制点Pk和Pk+1间的参数三次函数式，则从Pk-1到Pk+2间的四个控制点用于建立Cardinal样条段的边界条件：  
&nbsp; &nbsp; P(0)=Pk；P′(0)=(1-t)(Pk+1 –Pk-1)/2；P(1)=Pk+1； P′(1)=(1-t)(Pk+2 –Pk)/2 
* 控制点Pk和Pk+1处的斜率分别与弦Pk-1Pk+1和PkPk+2成正比。
* 参数t控制Cardinal样条与输入控制点间的松紧程度，称为张量(tension)参数。
* 类似于Hermite样条，转化为矩阵形式:  
![](https://i.imgur.com/UkBd8us.png "Cardinal矩阵形式")
* 值得注意的是，曲线也引入了角度的概念，与多边形类似，控制点线绕中心点旋转后得到新的控制点，再进行曲线绘制。
* 具体代码实现如下图：  
![](https://i.imgur.com/0HUsYuw.png "曲线算法")  
### 区域填充算法: 扫描线边界填充算法
* 核心：利用扫描显示特性，按扫描线检测和填充区域内部点。沿扫描线检测和填充水平像素段来代替按4连通或8连通的相邻像素扩展和填充方式。仅将每个水平像素段的起始像素进栈，减少存储相邻点的栈空间。
* 填充种子点像素所在扫描行的连续像素段，将相邻扫描线上各段的起始点位置像素进栈，各起始点	依次按“先进后出”从栈中取出，并填充该点所在水平段像素，重复以上的过程。
* 区域填充函数如下:  
![](https://i.imgur.com/mgCDdxl.png "区域填充")  
* 行填充函数：用于将每一段进行填充并返回该段的结束位置。
![](https://i.imgur.com/xSaemsT.png "行填充")
* 单行检查函数：用于将各待填充段的起始点入栈。  
![](https://i.imgur.com/nGjYyY8.png "单行检查找寻各段起始点")
### 二维图元的平移算法
* 核心: 二维图元的控制点，如直线的两个端点、圆的直径的两个端点坐标、椭圆的外接矩形的对角两个顶点坐标、多边形和曲线的控制点坐标。记录鼠标点下的位置、松开的位置，这两个位置的距离差即为平移的距离，将该距离加在二维图元的控制点坐标上，并重新绘制该二维图元。
* 需要注意的是，有些图元带有角度属性，如：椭圆需要由平移后的控制点绘制得到椭圆上的点，之后在旋转得到最终的点；而多边形，曲线，需要将平移的控制点旋转后再绘制。
### 二维图元的旋转算法
* 核心: 当选择旋转功能后，记录鼠标点下的位置和松开的位置，这两个点分别于二维图元的中心点相连，构成两个向量，这两个向量的夹角即为二维图元旋转的角度（带有正负符号）。因为该角度是带有正负的，所以需要先计算这两个向量的叉积结果判断旋转方向是顺时针还是逆时针。若原图元为直线和圆则将控制点旋转为新点后再绘制，若原图元为椭圆或者多边形或者曲线，则在原椭圆角度属性上加上新的角度，并绘制该椭圆。
* 值得一提的是，由于椭圆的旋转是在标准椭圆的基础上将每一个点进行旋转得到新的点，但是这样旋转后的得到的点所形成的椭圆可能不是封闭的。对这样的椭圆进行填充时，会将椭圆外的区域也会填充到。所以考虑用三层点绘制椭圆，分别为：(x, y), (x+1, y), (x, y+1)。
### 二维图元的缩放算法
* 核心: 当选择缩放功能后，记录鼠标点下的位置和松开的位置，这两个点分别计算出到二维图元中心的距离，这两个距离的比值即为缩放的倍数multiple，并将二维图元的控制点到二维图元中心的距离变为原来的multiple倍，并重新绘制图元。
* 关于中心点的计算，一律采用，控制点的算术平均点即物理上的质心作为中心点。
### 二维图元的编辑算法
* 核心: 编辑功能可以通过拖拽的方式更改图元的控制点位置，根据新的控制点绘制图形，当鼠标点击时，判断鼠标位置是否接近图元的控制点，若是，则控制点跟随鼠标拖拽的轨迹动态移动(动态绘制新的图元，擦除旧的图元)，当鼠标松开时，一次编辑完成，新的控制点暂时确定。绘制新的图元信息。编辑的本质在于控制点的更新与修改。
* 值得一提的是，椭圆控制点在逻辑上记录的是标准椭圆(即不考虑旋转角度)的控制点信息，但是在用户面前显示并且试试拖拽操作的是旋转后的控制点，两者间相差一个旋转矩阵。
### 裁剪算法: 梁友栋-Barsky参数裁剪算法
* 算法核心: 一条两端点为P1（x1，y1）、P2（x2，y2）的线段可以用参数方程形式表示：  
	x= x1+ u·（x2-x1）= x1+ u·Δx， y= y1+ u·（y2-y1）= y1+ u·Δy， 0≤u≤1
* 式中，Δx=x2-x1，Δy=y2-y1，参数u在0～1之间取值，P（x，y）代表了该线段上的一个点，其值由参数u确定，由公式可知，当u=0时，该点为P1（x1，y1），当u=1时，该点为P2（x2，y2）。如果点P（x，y）位于由坐标（xmin，ymin）和（xmax，ymax）所确定的窗口内，那么下式成立：  
	xmin≤x1+ u·Δx≤xmax， ymin≤y1+ u·Δy≤ymax， 0≤u≤1
* 这四个不等式可以表示为：u·pk ≤qk ， k=1，2，3，4
* 其中，p、q定义为：p1=-Δx， q1=x1-xmin p2= Δx， q2=xmax-x1 p3=-Δy， q3=y1-ymin，p4= Δy， q4=ymax-y1
* 从（4）式可以知道：任何平行于窗口某边界的直线，其pk=0，k值对应于相应的边界（k=1，2，3，4对应于左、右、下、上边界）。如果还满足qk<0，则线段完全在边界外，应舍弃该线段。如果pk=0并且qk≥0，则线段平行于窗口某边界并在窗口内，见图中所示。公式（4）式还告诉我们：  
	1、当pk<0时，线段从裁剪边界延长线的外部延伸到内部；  
	2、当pk>0时，线段从裁剪边界延长线的内部延伸到外部；
* 对于每条直线，可以计算出参数u1和u2，该值定义了位于窗口内的线段部分：  
	1、u1的值由线段从外到内遇到的矩形边界所决定（pk<0），对这些边界计算rk=qk/pk，u1取0和各个r值之中的最大值。  
	2、u2的值由线段从内到外遇到的矩形边界所决定（pk>0），对这些边界计算rk=qk/pk，u2取0和各个r值之中的最小值。  
	3、如果u1>u2，则线段完全落在裁剪窗口之外，应当被舍弃；否则，被裁剪线段的端点可以由u1和u2计算出来。
* 给出代码实现:   
![](https://i.imgur.com/ocrRVUI.png "梁友栋-Barsky参数裁剪算法")
### 三维模型显示与观察算法
* 算法核心: 通过OpenGL库读取OFF文件，并重写paintGL函数，每再次刷新时都会调用该函数进行绘制。
* 对于OFF文件，其格式如下: 第一行OFF标识文件信息，第二行给出该文件保存的三维图元涉及的顶点个数，面个数，边个数。接下来是所有点的坐标信息，每个点都有x，y，z三个方向上的坐标值。再接下来是面的信息，在每一行面的信息包括，该面上的顶点数，每个顶点在刚刚顶点数据中的索引号。
* 首先需要将顶点信息，面信息用数据结构存储起来，此处自定义存储顶点和面的结构体，并用vector容器存储。  
![](https://i.imgur.com/B2dwnkZ.png "MyGl结构体")
* 其次在绘制面时，通过记录的索引逐个去顶点容器中寻找对应的点，并在GL_TRIANGLES模式下通过glVertex3f函数绘制顶点，这样就构成了一个面。将所有的面绘制出即绘制出了整个三维模型。此外，还可在GL_LINES模式下调用glVertex3f函数绘制纹理。  
* 给出代码实现:  
![](https://i.imgur.com/EKmSBDY.png "三维模型显示算法")
* 对于观察，在该类中重写keyPressEvent函数，捕捉用户按下的每一个按键，并修改三个自定义的参数: leftright，updown，scale，分别表示左右旋转角度，上下旋转角度和缩放尺寸，并调用glRotatef和glScalef函数进行动态绘制。
* 打开的文件路径支持中文字符，此处采用修改编码的方式将中文字符变成可读。  
![](https://i.imgur.com/8KUk1Jd.png "三维模型文件路径支持中文")
## 系统介绍
### MainWindow类(主窗口)
* 主要功能控制整个程序主窗口中的布局，包括工具栏位置和其信号量，槽函数的设置，以及画布的放置和控制主窗口与画布类的消息传递。
* 首先设置画布类Painter在主窗口中的大小，位置，颜色等信息，并将画布放置在主窗口中间。  
![](https://i.imgur.com/SB9ictS.png "MainWindow类")
* 其次设置工具栏，并在工具栏上放置各个功能的按钮，并将这些按钮产生的信号与画布类中一些槽函数进行绑定。具体功能包括: 绘制直线，圆，椭圆，多边形，曲线，编辑，平移，旋转，缩放，填充，裁剪，保存，打开图片，选择画笔颜色等功能。该类中所调用的槽函数都为画布类mypainter类中的公共槽函数：  
![](https://i.imgur.com/wMiCVfE.png "槽函数")
### mypainter类(画布)
* 主要功能: mypainter类是画布类，MainWindow类所展示的对象即为该类对象，也是用户绘图所在的窗口。用户在画布上绘图时，用于调度鼠标，不同功能切换，画布的绘制。父类为QWidget类，需要重载五个函数：  
	void paintEvent(QPaintEvent *event)  
	void mouseMoveEvent(QMouseEvent *event)  
	void mouseReleaseEvent(QMouseEvent *event)  
	void mousePressEvent(QMouseEvent *event)
	void closeEvent(QCloseEvent *event)  
* mypainter类中私有成员变量如下：  
![](https://i.imgur.com/kcYqREq.png "mypainter类中私有成员")  
* image，newImage和bufferImage这三个QImage类指针用于存储用户绘制和编辑的图片信息，newImage和bufferImage用于存储还未编辑完当前图元时的整个画布的像素信息，而image用于存储编辑完的当前图元时的画布的像素信息。
* start和end用于存储鼠标点击与松开时的位置。
* theShape用于存储当前绘制的基本图形信息，由于存储结构不一样，polygon用于存储当前绘制的多边形的图形信息，curve用于存储当前绘制的曲线的图形信息。
* fill，translation，rotate，zoom，edit，cut分别为填充，平移，旋转，缩放，编辑，裁剪六个功能的指针，并在用户选择对应功能的时候通关这几个指针调用相关的方法。
* currentShape变量用于存储当前绘制的是什么图形，而currentFunc用于存储当前用户选择的是什么功能。
* isModified变量用于存储当前图像是否被更改过，如果被更改过，则在用户退出时询问用户是否要保存。
* color变量用于存储当前画笔的颜色。
#####mypainter类中主要函数说明:
* 鼠标事件函数：包括点击鼠标，拖拽鼠标，松开鼠标三个鼠标事件。
* 对于点击鼠标事件，其主要功能在于确定鼠标起始位置，存储起点信息。此外该方法还需在编辑功能和绘制多边形下判断当前鼠标所点位置是否为当前图元的控制点。并在特定功能下改变鼠标的指针样式。
![](https://i.imgur.com/xkYqYPo.png "mousePressEvent事件")
* 对于鼠标松开和鼠标拖拽事件，功能较为相似，switch语句下选择当前功能，并调用不同功能的处理函数，但不同的是，拖拽事件是在用户拖动鼠标时跟随当前鼠标位置动态绘制图元，需要不断绘制。此处采用较为巧妙的思想：本来拖拽过程的动态绘制需要擦除上一帧绘制的图像，然后绘制当前的图元。这样的方法较为繁琐，且计算量大。于是采用新增一个QImage对象，才用户没有确定图元绘制的最终画面前都会在这个新增的对象上绘制，并且每一次操作前都复制一遍最初的图像，这样就可以动态绘制图元并且不需要过多的计算量了。
* 打开现有图像并加载为图片的函数open：
![](https://i.imgur.com/CUs2TzM.png "open函数")
* 保存用户绘制的图片，并由用户选择保存路径和文件名函数save：
![](https://i.imgur.com/jm3rOix.png "save函数")
* 退出按钮响应事件处理函数closeEvent：在用户点击退出时，判断当前图片是否已经被修改过，如果被修改过且尚未保存则询问用户是否进行保存，并由用户选择保存路径，输入文件名。  
![](https://i.imgur.com/88sg1oS.png "closeEvent函数")
* 判断当前鼠标点击点是否为控制点的函数judgeIsAnchor，如果是控制点则返回控制点序号，否则返回-1.每个图形都有其控制点，该函数会对当前鼠标点击的位置与当前图元所有控制点进行一一比对，判断是否足够接近(此处判断方法为像素点间的距离小于等于3)。
* 选择画笔颜色的函数changeFuncToColor，该函数中首先调用QColorDialog有用户选择需要的颜色，当点击确认后，将选择的颜色赋值给color变量，如果没有点击确认，则获取到的颜色值为空，则不修改color变量的值。
![](https://i.imgur.com/A0vxG9q.png "画笔颜色")
### Shape类及其子类(MyLine类,MyCircle类,MyEllipse类)
* 图形类中主要函数为绘制函数(虚函数)void drawMyself(QImage *image),此处采用虚函数的目的是使用动态绑定的方式，根据Shape类型指针指向的具体图形动态调用不同图形类中的drawMyself函数。而drawMyself函数即为前面算法中讨论过的图形绘制算法，此处不过多赘述。数据成员即为各个图形的控制点信息，椭圆会多出一个角度	angle的概念。
* 动态绑定利用了面向对象编程思想中的多态性，也满足了里式替换法则。
![](https://i.imgur.com/L1kT5dA.png "Shape类")
* 给出该大类的UML类图:  
![](https://i.imgur.com/0n0mX1W.png "UML类图")
### MyPolygon类(多边形)
* 该类主要提供两个函数，一个是在用户绘制时，每点击一下就绘制改单与上一个控制点之间的连线，并最后形成闭合图形的函数。另一个函数则是图元变换和编辑中调用的绘制整体多边形的函数。都是对直线绘制函数的复用。  
![](https://i.imgur.com/sTAemVm.png "MyPolygon类")
### MyCurve类(曲线)
* 该类主要提供两个函数，drawTheCurve函数用来绘制当前的曲线，Matrix函数用来获取与Cardinal矩阵相乘结果获取新的点。具体绘制算法在前面讨论过，此处不过多赘述。  
![](https://i.imgur.com/55boKyB.png "MyCurve类")
### Fill类(区域填充)
* 填充类中主要函数即为fillTheArea函数，该函数采用扫描线边界填充算法，调度过程则有另两个函数fillTheLine和checkTheLine函数对线段填充，并获取新的待填充线段起始点，这些都已在前面算法中讨论过，此处不过多赘述。  
![](https://i.imgur.com/nd2luJ3.png "Fill类")
### Translation类(二维图元平移)
* 该类中主要函数即为translationTheShape,需要注意的是，由于不同的图元存储的结构不一样，比如基本的三个图形和多边形，曲线就采用了不一样的存储结构，所以该函数会有三个不同的重载，分别对应于三个基本图元(圆，直线，椭圆)，多边形，曲线的平移。该函数采用的算法，已在前面算法中讨论过，此处不过多赘述。
![](https://i.imgur.com/BUnz0qA.png "Translation类")
### Rotate类(二维图元旋转)
* 该类中主要函数即为rotateTheShape函数，需要注意的是，由于不同的图元存储的结构不一样，比如基本的三个图形和多边形，曲线就采用了不一样的存储结构，所以该函数会有三个不同的重载，分别对应于三个基本图元(圆，直线，椭圆)，多边形，曲线的旋转。该函数采用的算法，已在前面算法中讨论过，此处不过多赘述。
![](https://i.imgur.com/Sr4mVEu.png "Rotate类")
### Zoom类(二维图元缩放)
* 该类中主要函数即为zoomTheShape函数，需要注意的是，由于不同的图元存储的结构不一样，比如基本的三个图形和多边形，曲线就采用了不一样的存储结构，所以该函数会有三个不同的重载，分别对应于三个基本图元(圆，直线，椭圆)，多边形，曲线的缩放。该函数采用的算法，已在前面算法中讨论过，此处不过多赘述。
![](https://i.imgur.com/5x2LaeY.png "Zoom类")
### Edit类(二维图元编辑)
* 该类中主要函数即为editTheShape函数，需要注意的是，由于不同的图元存储的结构不一样，比如基本的三个图形和多边形，曲线就采用了不一样的存储结构，所以该函数会有三个不同的重载，分别对应于三个基本图元(圆，直线，椭圆)，多边形，曲线的编辑。该函数采用的算法，已在前面算法中讨论过，此处不过多赘述。
![](https://i.imgur.com/psGai1o.png "Edit类")
### Cut类(裁剪)
* 该类中主要函数即为void doCut(QImage* image, QPoint recMin, QPoint recMax, Shape* &shape, QColor* color)函数，采用的算法为梁友栋-Barsky参数裁剪算法，裁剪框可动态编辑，对刚刚绘制完的直线进行裁剪。具体算法在前面已经讨论过，此处不过多赘述。
![](https://i.imgur.com/dGBQ7QY.png "Cut类")
### MyGl类(三维模型的展示和观察)
* 该类主要函数为四个重载函数initializeGL，resizeGL，paintGL，keyPressEvent。其中initializeGL用于初始化当前的opengl环境，resizeGL主要用来对渲染区域的高度和宽度进行一些变化处理，paintGL用于绘制当前视角下的模型，keyPressEvent用于捕捉键盘事件来控制观察视角，包括左右上下旋转和靠近远离等。  
![](https://i.imgur.com/R8g4reK.png "MyGl类")
## 结束语
* 本系统主要完成的功能有：二维图元的绘制，编辑，变换，裁剪；区域填充；读取现有图片，保存当前图像为图片；选择画笔颜色；三维图元的展示和由用户控制视角观察。并在原先基础上有一定的创新。用户交互能力有好，用户友善度较高。
* 大作业锻炼了动手能力，培养了独立完成较大变成任务的能力，深化了对图形学知识的理解。
* 对面向对象编程思想理解更加深入，并在项目中采用了相关设计原则和设计模式。(里氏替换原则和适配器模式，装饰器模式等)
* 培养了对图形学方向的兴趣。
##参考文献
* 《计算机图形学教程》 孙正兴主编
* Qt官方手册
* 《Qt学习之路》 [https://blog.csdn.net/mars_xiaolei/article/details/79424315](https://blog.csdn.net/mars_xiaolei/article/details/79424315)
* Cardinal样条曲线的Javascript实现（理论篇）[https://www.cnblogs.com/sparkmorry/p/3535936.html](https://www.cnblogs.com/sparkmorry/p/3535936.html)